{
  parserClass="com.cwlplugin.parser.CwlParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Cwl"
  psiImplClassSuffix="Impl"
  psiPackage="com.cwlplugin.psi"
  psiImplPackage="com.cwlplugin.psi.impl"

  elementTypeHolderClass="com.cwlplugin.psi.CwlTypes"
  elementTypeClass="com.cwlplugin.psi.CwlElementType"
  tokenTypeClass="com.cwlplugin.psi.CwlTokenType"

  // These tokens are just for Interactive Preview
  tokens = [
  CWL_VERSION = "cwlVersion"
  VERSION = "v1.0"
  REQUIREMENTS = "requirements"
  CLASS = "class"
  INPUTS = "inputs"
  OUTPUTS = "outputs"
  COLON = ":"
  space="regexp:\s+"
  BASECOMMAND = "baseCommand"
  FILE="file"
//  COMMAND = "regexp:\w*"
  COMMAND = "ls"
  IDENTIFIER = "input_file"
//  IDENTIFIER = "regexp:([\w]*)"
  LABEL = "label"
  TYPE = "type"
  SECONDARY_FILES = "secondaryFiles"
  DOC = "doc"
  GLOB = "glob"
  FORMAT = "format"
  STREAMABLE = "streamable"
  INPUT_BINDING = "inputBinding"
  DEFAULT = "default"
//  STRING = "regexp:(\s\|[\n\r]\w)"
  STRING = "some_string"
  LOAD_CONTENTS = "loadContents"
  POSITION = "position"
  PREFIX = "prefix"
  SEPARATE = "separate"
  ITEM_SEPARATOR = "itemSeparator"
  VALUE_FROM = "valueFrom"
  SHELL_QUOTE = "shellQuote"
  INT = "regexp:\d+"
  BOOLEAN = "True"
  OUTPUT_EVAL = "outputEval"
  EXPRESSION = "$()"
  STRING_TYPE = "string"
  COMMAND_LINE_TOOL = "CommandLineTool"
  ANY = "*"
  ID = "id"
  NUMBER = "regexp:\d+"
  ENUM = "enum"
  DOCKER_REQUIREMENT = "DockerRequirement"
  INLINE_JAVASCRIPT_REQUIREMENT
  SCHEMA_DEF_REQUIREMENT
  DOCKER_REQUIREMENT
  SOFTWARE_REQUIREMENT
  // array<InlineJavascriptRequirement | SchemaDefRequirement | DockerRequirement | SoftwareRequirement | InitialWorkDirRequirement | EnvVarRequirement | ShellCommandRequirement | ResourceRequirement>	False
  ]

//  psiImplUtilClass="com.cwlplugin.psi.impl.CwlPsiImplUtil"
}

//Make cwlVersion the first line
cwl_file ::= !<<eof>> cwl_version tool_description

private cwl_version ::= CWL_VERSION COLON VERSION

tool_description ::= CLASS COLON tool
tool ::= (commandline_tool | expression_tool | workflow)

commandline_tool ::=
    (COMMAND_LINE_TOOL
    | inputs
    | outputs
    | class
    | base_command
    | requirements
    | id
    | label
    | doc
    | hints
    | arguments
    | stderr
    | stdin
    | stdout
    | success_codes
    | temporary_fail_codes
    | permanent_fail_codes
    )

class ::= CLASS COLON STRING
// string	True
id
// string	False
requirements ::= REQUIREMENTS COLON requirement *
requirement ::= (
inline_javascript_requirement
| schema_def_requirement
| docker_requirement
| software_requirement
| initial_workdir_requirement
| env_var_requirement
| shell_command_requirement
| resource_requirement
)

inline_javascript_requirement ::= CLASS COLON INLINE_JAVASCRIPT_REQUIREMENT
schema_def_requirement ::= CLASS COLON SCHEMA_DEF_REQUIREMENT
docker_requirement ::= CLASS COLON DOCKER_REQUIREMENT docker_requirement_field *
docker_requirement_field ::= (
docker_pull
| docker_load
| docker_file
| docker_import
| docker_image_id
| docker_output_directory)
docker_pull ::= DOCKER_PULL COLON STRING
docker_load ::= DOCKER_LOAD COLON STRING
docker_file ::= DOCKER_FILE COLON STRING
docker_import ::= DOCKER_IMPORT COLON STRING
docker_image_id ::= DOCKER_IMAGE_ID COLON STRING
docker_output_directory ::= DOCKER_OUTPUT_DIRECTORY COLON STRING

software_requirement ::= CLASS COLON SOFTWARE_REQUIREMENT packages
packages ::= software_package_array
software_package_array ::= "[" (software_package COMMA) * software_package "]"
software_package ::= (package | version | specs)
package ::= PACKAGE COLON STRING
version ::= VERSION COLON string_array
specs ::= SPECS COLON string_array

initial_workdir_requirement ::= CLASS COLON INITIAL_WORKDIR_REQUIREMENT initial_workdir_listing
initial_workdir_listing ::= file_array | directory_array | dirent_array | string_array | expression_array | STRING | EXPRESSION
// array<File | Directory | Dirent | string | Expression>
dirent_array ::= "[" (dirent COMMA) * dirent "]"
dirent ::= (entry | entryname | writable)
entry ::= ENTRY COLON (STRING | EXPRESSION)
entryname ::= ENTRYNAME COLON (STRING | EXPRESSION)
writable ::= WRITABLE COLON BOOLEAN

// TODO Maybe make all required fields autogenerated and preordered?
env_var_requirement ::= CLASS COLON ENV_VAR_REQUIREMENT env_def
env_def ::= env_name env_value
env_name ::= ENV_NAME COLON STRING
env_value ::= ENV_VALUE COLON (STRING | EXPRESSION)

shell_command_requirement ::= CLASS COLON SHELL_COMMAND_REQUIREMENT

resource_requirement ::= CLASS COLON RESOURCE_REQUIREMENT resource_requirement_field *
resource_requirement_field ::= (
cores_min
| cores_max
| ram_min
| ram_max
| tmpdir_min
| tmpdir_max
| outdir_min
| outdir_max
)
cores_min ::= CORES_MIN COLON (NUMBER | STRING | EXPRESSION)
cores_max ::= CORES_MAX COLON (NUMBER | STRING | EXPRESSION)
ram_min ::= RAM_MIN COLON (NUMBER | STRING | EXPRESSION)
ram_max ::= RAM_MAX COLON (NUMBER | STRING | EXPRESSION)
tmpdir_min ::= TMPDIR_MIN COLON (NUMBER | STRING | EXPRESSION)
tmpdir_max ::= TMPDIR_MAX COLON (NUMBER | STRING | EXPRESSION)
outdir_min ::= OUTDIR_MIN COLON (NUMBER | STRING | EXPRESSION)
outdir_max ::= OUTDIR_MAX COLON (NUMBER | STRING | EXPRESSION)

// array<InlineJavascriptRequirement | SchemaDefRequirement | DockerRequirement | SoftwareRequirement | InitialWorkDirRequirement | EnvVarRequirement | ShellCommandRequirement | ResourceRequirement>	False
hints ::= HINTS COLON STRING *
// array<Any>	False
base_command ::= BASECOMMAND COLON (STRING | string_array)
// string | array<string>	False
arguments ::= (string_array | expression_array | command_line_binding_array)
// array<string | Expression | CommandLineBinding>	False
stdin ::= STRING | EXPRESSION
// string | Expression	False
stderr ::= STRING | EXPRESSION
// string | Expression	False
stdout ::= STRING | EXPRESSION
//	string | Expression	False

success_codes ::= int_array
// array<int>	False
temporary_fail_codes ::= int_array
//	array<int>	False
permanent_fail_codes ::= int_array
//	array<int>	False


// array<CommandInputParameter> | map<CommandInputParameter.id, CommandInputParameter.type> | map<CommandInputParameter.id, CommandInputParameter>	True
inputs ::= INPUTS COLON command_input_parameter *

command_input_parameter ::= IDENTIFIER COLON command_input_parameter_field *
command_input_parameter_field ::= ( default | doc | format | id | input_binding | label | secondary_files | streamable | type )

default ::= DEFAULT COLON ANY
doc ::= DOC COLON (STRING | string_array)
format ::= FORMAT COLON (STRING | string_array | EXPRESSION)
id ::= ID COLON STRING

input_binding ::= command_line_binding
command_line_binding ::= COLON command_line_binding_field *
command_line_binding_field ::=
(
load_contents
| value_from
| position
| separate
| item_separator
| prefix
| shell_quote
)

value_from ::= VALUE_FROM COLON (STRING | EXPRESSION)
position ::= POSITION COLON INT
separate ::= SEPARATE COLON BOOLEAN
item_separator ::= ITEM_SEPARATOR COLON STRING
prefix ::= PREFIX COLON STRING
shell_quote ::= SHELL_QUOTE COLON BOOLEAN
load_contents ::= LOAD_CONTENTS COLON BOOLEAN  // Only valid when type: File or is an array of items: File

label ::= LABEL COLON STRING
secondary_files ::= SECONDARY_FILES COLON (STRING | EXPRESSION | string_array | expression_array)
streamable ::= STREAMABLE COLON BOOLEAN
type ::= TYPE COLON STRING_TYPE

string_array ::= "[" (STRING COMMA) * STRING "]"
expression_array ::= "[" (EXPRESSION COMMA) * EXPRESSION "]"
command_line_binding_array ::= "[" (command_line_binding COMMA) * command_line_binding "]"
int_array ::= "[" (INT COMMA) * INT "]"
file_array ::= "[" (file COMMA) * file "]"
directory_array ::= "[" (directory COMMA) * directory "]"

// array<CommandOutputParameter> | map<CommandOutputParameter.id, CommandOutputParameter.type> | map<CommandOutputParameter.id, CommandOutputParameter>	True
outputs ::= OUTPUTS COLON command_output_parameter *

command_output_parameter ::= IDENTIFIER COLON command_output_parameter_field *
command_output_parameter_field ::= (id | label | secondary_files | format | streamable | doc | output_binding | type)
//private item ::= INPUTS COLON IDENTIFIER {pin=2 recoverWhile=rule_recover}

output_binding ::= command_output_binding
command_output_binding ::= COLON command_output_binding_field *
command_output_binding_field ::= (glob | load_contents | output_eval)
//property ::= (KEY? SEPARATOR VALUE?) | KEY {methods=[getKey getValue]}
glob ::= GLOB COLON (STRING | EXPRESSION | string_array)
output_eval ::= OUTPUT_EVAL COLON (STRING | EXPRESSION)

// TODO add expression_tool and workflow
expression_tool ::= ""
workflow ::=""

file ::= CLASS COLON FILE file_field *
file_field ::= (location | path | basename | dirname | nameroot | nameext | checksum | size | file_secondary_files | format | contents)
location ::= LOCATION COLON STRING
path ::= PATH COLON STRING
basename ::= BASENAME COLON STRING
dirname ::= DIRNAME COLON STRING
nameext ::= NAMEEXT COLON STRING
nameroot ::= NAMEROOT COLON STRING
checksum ::= CHECKSUM COLON STRING
size ::= SIZE COLON NUMBER
file_secondary_files ::= SECONDARY_FILES COLON (file_array | directory_array)
contents ::= CONTENTS COLON STRING

directory ::= CLASS COLON DIRECTORY directory_field *
directory_field ::= (location | path | basename | listing)
listing ::= LISTING COLON (file_array | directory_array) // The name of each file or subdirectory is determined by the basename field of each File or Directory object. It is an error if a File shares a basename with any other entry in listing. If two or more Directory object share the same basename, this must be treated as equivalent to a single subdirectory with the listings recursively merged.

command_input_record_schema ::= (record_type | label | command_input_record_fields )

record_type ::= TYPE COLON RECORD
command_input_record_fields ::= command_input_record_field *
command_input_record_field ::= (name | doc | input_binding | label | command_input_record_field_type)
command_input_record_field_type ::= (
cwl_type
| command_input_enum_schema
| STRING
| cwl_type_array
| command_input_record_schema_array
| command_input_enum_schema_array
| command_input_array_schema_array
| string_array
| command_input_record_schema
| command_input_array_schema
)
name ::= NAME COLON STRING

command_input_enum_schema ::= (symbols | enum_type | label | input_binding)
symbols ::= string_array
enum_type ::= TYPE COLON ENUM

command_input_array_schema ::= (array_type | label | input_binding | command_input_array_items)
array_type ::= TYPE COLON ARRAY
command_input_array_items ::= (
                          cwl_type
                          | command_input_enum_schema
                          | STRING
                          | cwl_type_array
                          | command_input_record_schema_array
                          | command_input_enum_schema_array
                          | command_input_array_schema_array
                          | string_array
                          | command_input_array_schema
                          | command_input_record_schema
                          )

command_output_record_schema ::= (record_type | command_output_record_fields | label)
command_output_record_fields ::= command_output_record_field *
command_output_record_field ::= (name | command_output_record_field_type | doc | output_binding)
command_output_record_field_type ::= (
cwl_type
| command_output_enum_schema
| STRING
| cwl_type_array
| command_output_record_schema_array
| command_output_enum_schema_array
| command_output_array_schema_array
| string_array
| command_output_record_schema
| command_output_array_schema
)

command_output_enum_schema ::= (symbols | enum_type | label | output_binding)
command_output_array_schema ::= (command_output_array_items | array_type | label | output_binding)
command_output_array_items ::= command_output_record_field_type


cwl_type ::= (
NULL_TYPE
| BOOLEAN_TYPE
| INT_TYPE
| LONG_TYPE
| FLOAT_TYPE
| DOUBLE_TYPE
| STRING_TYPE
| FILE
| DIRECTORY
)

cwl_type_array ::= "[" (cwl_type COMMA) * cwl_type "]"
command_output_record_schema_array ::= "[" (command_output_record_schema COMMA) * command_output_record_schema "]"
command_output_enum_schema_array ::= "[" (command_output_enum_schema COMMA) * command_output_enum_schema "]"
command_output_array_schema_array ::= "[" (command_output_array_schema COMMA) * command_output_array_schema "]"

command_input_record_schema_array ::= "[" (command_input_record_schema COMMA) * command_input_record_schema "]"
command_input_enum_schema_array ::= "[" (command_input_enum_schema COMMA) * command_input_enum_schema "]"
command_input_array_schema_array ::= "[" (command_input_array_schema COMMA) * command_input_array_schema "]"
docker_requirement