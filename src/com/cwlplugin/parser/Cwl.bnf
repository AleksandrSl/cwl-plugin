{
  parserClass="com.cwlplugin.parser.CwlParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Cwl"
  psiImplClassSuffix="Impl"
  psiPackage="com.cwlplugin.psi"
  psiImplPackage="com.cwlplugin.psi.impl"

  elementTypeHolderClass="com.cwlplugin.psi.CwlTypes"
  elementTypeClass="com.cwlplugin.psi.CwlElementType"
  tokenTypeClass="com.cwlplugin.lexer.CwlTokenType"

  // These tokens are just for Interactive Preview
  tokens = [
  ANY_TYPE_TK = "Any"
  ARRAY_TYPE_TK = "array"
  BASECOMMAND_TK = "baseCommand"
  BASENAME_TK = "basename"
  BOOLEAN_TK = "BOOLEAN_VALUE"
  BOOLEAN_TYPE_TK = "boolean"
  CHECKSUM_TK = "checksum"
  CLASS_TK = "class"
  COLON_TK = ":"
  COMMA_TK = ","
  COMMAND_LINE_TOOL_TK = "CommandLineTool"
  CONTENTS_TK = "contents"
  CORES_MAX_TK = "coresMin"
  CORES_MIN_TK = "coresMin"
  CWL_VERSION_TK = "cwlVersion"
  DEFAULT_TK = "default"
  DIRECTORY_TYPE_TK = "Directory"
  DIRNAME_TK = "dirname"
  DOC_TK = "doc"
  DOCKER_FILE_TK = "dockerFile"
  DOCKER_IMAGE_ID_TK = "dockerImageId"
  DOCKER_IMPORT_TK = "dockerImport"
  DOCKER_LOAD_TK = "dockerLoad"
  DOCKER_OUTPUT_DIRECTORY_TK = "dockerOutputDirectory"
  DOCKER_PULL_TK = "dockerPull"
  DOCKER_REQUIREMENT_TK = "DockerRequirement"
  DOUBLE_TYPE_TK = "double"
  ENTRY_TK = "entry"
  ENTRYNAME_TK = "entryname"
  ENUM_TYPE_TK = "enum"
  ENV_DEF_TK = "envDef"
  ENV_NAME_TK = "envName"
  ENV_VALUE_TK = "envValue"
  ENV_VAR_REQUIREMENT_TK = "EnvVarRequirement"
  EXPRESSION_TK = "$()"
  EXPRESSION_TOOL_TK = "ExpressionTool"
  FILE_TYPE_TK = "File"
  FLOAT_TYPE_TK = "float"
  FORMAT_TK = "format"
  GLOB_TK = "glob"
  HINTS_TK  = "hints"
  IDENTIFIER_TK = "IDENTIFIER"
  ID_TK = "id"
  INITIAL_WORKDIR_REQUIREMENT_TK = "InitialWorkDirRequirement"
  INLINE_JAVASCRIPT_REQUIREMENT_TK = "InlineJavascriptRequirement"
  INPUT_BINDING_TK = "inputBinding"
  INPUTS_TK = "inputs"
  INT_TK = "regexp:\d+"
  INT_TYPE_TK = "int"
  ITEM_SEPARATOR_TK = "itemSeparator"
  LABEL_TK = "label"
  LBRACKET_TK = "["
  LISTING_TK = "listing"
  LOAD_CONTENTS_TK = "loadContents"
  LOCATION_TK = "location"
  LONG_TYPE_TK = "long"
  NAME_TK = "name"
  NAMEEXT_TK = "nameext"
  NAMEROOT_TK = "nameroot"
  NULL_TYPE_TK = "null"
  NUMBER_TK = "regexp:\d+"
  OUTDIR_MAX_TK = "outdirMax"
  OUTDIR_MIN_TK = "outdirMin"
  OUTPUT_EVAL_TK = "outputEval"
  OUTPUTS_TK = "outputs"
  PACKAGE_TK = "package"
  PATH_TK = "path"
  PERMANENT_FAIL_CODES_TK = "permanentFailCodes"
  POSITION_TK = "position"
  PREFIX_TK = "prefix"
  RAM_MAX_TK = "ramMax"
  RAM_MIN_TK = "ramMin"
  RBRACKET_TK = "]"
  RECORD_TK = "record"
  REQUIREMENTS_TK = "requirements"
  RESOURCE_REQUIREMENT_TK = "ResourceRequirement"
  SCHEMA_DEF_REQUIREMENT_TK = "SchemaDefRequirement"
  SECONDARY_FILES_TK = "secondaryFiles"
  SEPARATE_TK = "separate"
  SHELL_COMMAND_REQUIREMENT_TK = "ShellCommandRequirement"
  SHELL_QUOTE_TK = "shellQuote"
  SIZE_TK = "size"
  SOFTWARE_REQUIREMENT_TK = "SoftwareRequirement"
  space="regexp:\s+"
  SPECS_TK = "specs"
  STREAMABLE_TK = "streamable"
  STRING_TK = "STRING_VALUE"
  STRING_TYPE_TK = "string"
  SUCCESS_CODES_TK = "successCodes"
  TEMPORARY_FAIL_CODES_TK = "temporaryFailCodes"
  TMPDIR_MAX_TK = "tmpdirMax"
  TMPDIR_MIN_TK = "tmpdirMin"
  TYPE_TK = "type"
  VALUE_FROM_TK = "valueFrom"
  CWL_VERSION_VALUE_TK = "v1.0"
  VERSION_TK = "version"
  WORKFLOW_TK = "Workflow"
  WRITABLE_TK = "writable"
]

//  psiImplUtilClass="com.cwlplugin.psi.CwlPsiImplUtilKt"
}

//Make cwlVersion the first line
cwl_file ::= !<<eof>> cwl_version tool_description

private cwl_version ::= CWL_VERSION_TK COLON_TK CWL_VERSION_VALUE_TK

tool_description ::= (command_line_tool)

command_line_tool ::= command_line_tool_field *
command_line_tool_field ::= (
    inputs
    | outputs
    | command_line_tool_class
    | base_command
    | requirements
    | id
    | label
    | doc
    | hints
    | arguments
    | stderr
    | stdin
    | stdout
    | success_codes
    | temporary_fail_codes
    | permanent_fail_codes
    )

command_line_tool_class ::= CLASS_TK COLON_TK COMMAND_LINE_TOOL_TK
// string	True
requirements ::= REQUIREMENTS_TK COLON_TK  requirement +
requirement ::= (
inline_javascript_requirement
| schema_def_requirement
| docker_requirement
| software_requirement
| initial_workdir_requirement
| env_var_requirement
| shell_command_requirement
| resource_requirement
)

inline_javascript_requirement ::= CLASS_TK COLON_TK INLINE_JAVASCRIPT_REQUIREMENT_TK
schema_def_requirement ::= CLASS_TK COLON_TK SCHEMA_DEF_REQUIREMENT_TK
docker_requirement ::= CLASS_TK COLON_TK DOCKER_REQUIREMENT_TK  docker_requirement_field +
docker_requirement_field ::= (
docker_pull
| docker_load
| docker_file
| docker_import
| docker_image_id
| docker_output_directory)
private docker_pull ::= DOCKER_PULL_TK COLON_TK STRING_TK
private docker_load ::= DOCKER_LOAD_TK COLON_TK STRING_TK
private docker_file ::= DOCKER_FILE_TK COLON_TK STRING_TK
private docker_import ::= DOCKER_IMPORT_TK COLON_TK STRING_TK
private docker_image_id ::= DOCKER_IMAGE_ID_TK COLON_TK STRING_TK
private docker_output_directory ::= DOCKER_OUTPUT_DIRECTORY_TK COLON_TK STRING_TK

software_requirement ::= CLASS_TK COLON_TK SOFTWARE_REQUIREMENT_TK  packages
packages ::= software_package_array
software_package_array ::= LBRACKET_TK (software_package COMMA_TK) * software_package RBRACKET_TK
software_package ::= (package | version | specs)
private package ::= PACKAGE_TK COLON_TK STRING_TK
private version ::= VERSION_TK COLON_TK string_array
private specs ::= SPECS_TK COLON_TK string_array

initial_workdir_requirement ::= CLASS_TK COLON_TK INITIAL_WORKDIR_REQUIREMENT_TK  initial_workdir_listing
initial_workdir_listing ::= file_array | directory_array | dirent_array | string_array | expression_array | STRING_TK | EXPRESSION_TK
// array<File | Directory | Dirent | string | Expression>
dirent_array ::= LBRACKET_TK (dirent COMMA_TK) * dirent RBRACKET_TK
dirent ::= (entry | entryname | writable)
private entry ::= ENTRY_TK COLON_TK (STRING_TK | EXPRESSION_TK)
private entryname ::= ENTRYNAME_TK COLON_TK (STRING_TK | EXPRESSION_TK)
private writable ::= WRITABLE_TK COLON_TK BOOLEAN_TK

// TODO Maybe make all required fields autogenerated and preordered?
env_var_requirement ::= CLASS_TK COLON_TK ENV_VAR_REQUIREMENT_TK  env_def
private env_def ::= ENV_DEF_TK COLON_TK env_name env_value
private env_name ::= ENV_NAME_TK COLON_TK STRING_TK
private env_value ::= ENV_VALUE_TK COLON_TK (STRING_TK | EXPRESSION_TK)

shell_command_requirement ::= CLASS_TK COLON_TK SHELL_COMMAND_REQUIREMENT_TK

resource_requirement ::= CLASS_TK COLON_TK RESOURCE_REQUIREMENT_TK resource_requirement_field *
resource_requirement_field ::= (
cores_min
| cores_max
| ram_min
| ram_max
| tmpdir_min
| tmpdir_max
| outdir_min
| outdir_max
)
private cores_min ::= CORES_MIN_TK COLON_TK (NUMBER_TK | STRING_TK | EXPRESSION_TK)
private cores_max ::= CORES_MAX_TK COLON_TK (NUMBER_TK | STRING_TK | EXPRESSION_TK)
private ram_min ::= RAM_MIN_TK COLON_TK (NUMBER_TK | STRING_TK | EXPRESSION_TK)
private ram_max ::= RAM_MAX_TK COLON_TK (NUMBER_TK | STRING_TK | EXPRESSION_TK)
private tmpdir_min ::= TMPDIR_MIN_TK COLON_TK (NUMBER_TK | STRING_TK | EXPRESSION_TK)
private tmpdir_max ::= TMPDIR_MAX_TK COLON_TK (NUMBER_TK | STRING_TK | EXPRESSION_TK)
private outdir_min ::= OUTDIR_MIN_TK COLON_TK (NUMBER_TK | STRING_TK | EXPRESSION_TK)
private outdir_max ::= OUTDIR_MAX_TK COLON_TK (NUMBER_TK | STRING_TK | EXPRESSION_TK)

// array<InlineJavascriptRequirement | SchemaDefRequirement | DockerRequirement | SoftwareRequirement | InitialWorkDirRequirement | EnvVarRequirement | ShellCommandRequirement | ResourceRequirement>	False
hints ::= HINTS_TK COLON_TK STRING_TK *
// array<Any>	False
base_command ::= BASECOMMAND_TK COLON_TK (STRING_TK | string_array)
// string | array<string>	False
arguments ::= (string_array | expression_array | command_line_binding_array)
// array<string | Expression | CommandLineBinding>	False
stdin ::= STDIN_TK COLON_TK STRING_TK | EXPRESSION_TK
// string | Expression	False
stderr ::= STDERR_TK COLON_TK STRING_TK | EXPRESSION_TK
// string | Expression	False
stdout ::= STDOUT_TK COLON_TK STRING_TK | EXPRESSION_TK
//	string | Expression	False

success_codes ::= SUCCESS_CODES_TK COLON_TK int_array
// array.<int>	False
temporary_fail_codes ::= TEMPORARY_FAIL_CODES_TK COLON_TK int_array
//	array<int>	False
permanent_fail_codes ::= PERMANENT_FAIL_CODES_TK COLON_TK int_array
//	array<int>	False


// array<CommandInputParameter> | map<CommandInputParameter.id, CommandInputParameter.type> | map<CommandInputParameter.id, CommandInputParameter>	True
inputs ::= INPUTS_TK COLON_TK  command_input_parameter + 

command_input_parameter ::= IDENTIFIER_TK COLON_TK  command_input_parameter_field +

command_input_parameter_field ::= ( default | doc | format | id | input_binding | label | secondary_files | streamable | type )

private default ::= DEFAULT_TK COLON_TK STRING_TK  // Could be of type Any, but yaml string is any indeed
private doc ::= DOC_TK COLON_TK (STRING_TK | string_array)
private format ::= FORMAT_TK COLON_TK (STRING_TK | string_array | EXPRESSION_TK)
private id ::= ID_TK COLON_TK STRING_TK

input_binding ::= INPUT_BINDING_TK COLON_TK  command_line_binding_field +
command_line_binding_field ::=
(
load_contents
| value_from
| position
| separate
| item_separator
| prefix
| shell_quote
)

private value_from ::= VALUE_FROM_TK COLON_TK (STRING_TK | EXPRESSION_TK)
private position ::= POSITION_TK COLON_TK INT_TK
private separate ::= SEPARATE_TK COLON_TK BOOLEAN_TK
private item_separator ::= ITEM_SEPARATOR_TK COLON_TK STRING_TK
private prefix ::= PREFIX_TK COLON_TK STRING_TK
private shell_quote ::= SHELL_QUOTE_TK COLON_TK BOOLEAN_TK
private load_contents ::= LOAD_CONTENTS_TK COLON_TK BOOLEAN_TK  // Only valid when type: File or is an array of items: File

label ::= LABEL_TK COLON_TK STRING_TK
secondary_files ::= SECONDARY_FILES_TK COLON_TK  (STRING_TK | EXPRESSION_TK | string_array | expression_array)
streamable ::= STREAMABLE_TK COLON_TK BOOLEAN_TK
type ::= TYPE_TK COLON_TK STRING_TYPE_TK

private string_array ::= LBRACKET_TK (STRING_TK COMMA_TK) * STRING_TK RBRACKET_TK
private expression_array ::= LBRACKET_TK (EXPRESSION_TK COMMA_TK) * EXPRESSION_TK RBRACKET_TK
private command_line_binding_array ::= LBRACKET_TK (input_binding COMMA_TK) * input_binding RBRACKET_TK
int_array ::= LBRACKET_TK (INT_TK COMMA_TK) * INT_TK RBRACKET_TK
file_array ::= LBRACKET_TK (file_ COMMA_TK) * file_ RBRACKET_TK
directory_array ::= LBRACKET_TK (directory COMMA_TK) * directory RBRACKET_TK

// array<CommandOutputParameter> | map<CommandOutputParameter.id, CommandOutputParameter.type> | map<CommandOutputParameter.id, CommandOutputParameter>	True
outputs ::= OUTPUTS_TK COLON_TK  command_output_parameter +

command_output_parameter ::= IDENTIFIER_TK COLON_TK  command_output_parameter_field +
command_output_parameter_field ::= (id | label | secondary_files | format | streamable | doc | output_binding | type)

output_binding ::= command_output_binding
command_output_binding ::= COLON_TK  command_output_binding_field + 
command_output_binding_field ::= (glob | load_contents | output_eval)
private glob ::= GLOB_TK COLON_TK (STRING_TK | EXPRESSION_TK | string_array)
private output_eval ::= OUTPUT_EVAL_TK COLON_TK (STRING_TK | EXPRESSION_TK)

// TODO add expression_tool and workflow
private expression_tool ::= " "
private workflow ::= " "

file_ ::= CLASS_TK COLON_TK FILE_TYPE  file_field +
file_field ::= (location | path | basename | dirname | nameroot | nameext | checksum | size | file_secondary_files | format | contents)
private location ::= LOCATION_TK COLON_TK STRING_TK
private path ::= PATH_TK COLON_TK STRING_TK
private basename ::= BASENAME_TK COLON_TK STRING_TK
private dirname ::= DIRNAME_TK COLON_TK STRING_TK
private nameext ::= NAMEEXT_TK COLON_TK STRING_TK
private nameroot ::= NAMEROOT_TK COLON_TK STRING_TK
private checksum ::= CHECKSUM_TK COLON_TK STRING_TK
private size ::= SIZE_TK COLON_TK NUMBER_TK
private file_secondary_files ::= SECONDARY_FILES_TK COLON_TK (file_array | directory_array)
private contents ::= CONTENTS_TK COLON_TK STRING_TK

directory ::= CLASS_TK COLON_TK DIRECTORY_TYPE_TK  directory_field +
directory_field ::= (location | path | basename | listing)
private listing ::= LISTING_TK COLON_TK (file_array | directory_array) // The name of each file or subdirectory is determined by the basename field of each File or Directory object. It is an error if a File shares a basename with any other entry in listing. If two or more Directory object share the same basename, this must be treated as equivalent to a single subdirectory with the listings recursively merged.

private left command_input_record_schema ::= (record_type | label | command_input_record_fields )

record_type ::= TYPE_TK COLON_TK RECORD_TK
command_input_record_fields ::= command_input_record_field *
command_input_record_field ::= (name | doc | input_binding | label | command_input_record_field_type)
command_input_record_field_type ::= (
cwl_type
| command_input_enum_schema
| STRING_TK
| cwl_type_array
| command_input_record_schema_array
| command_input_enum_schema_array
| command_input_array_schema_array
| string_array
| command_input_record_schema
| command_input_array_schema
)
private name ::= NAME_TK COLON_TK STRING_TK

command_input_enum_schema ::= (symbols | enum_type | label | input_binding)
symbols ::= string_array
private enum_type ::= TYPE_TK COLON_TK ENUM_TYPE

command_input_array_schema ::= (array_type | label | input_binding | command_input_array_items)
private array_type ::= TYPE_TK COLON_TK ARRAY_TYPE
command_input_array_items ::= (
                          cwl_type
                          | command_input_enum_schema
                          | STRING_TK
                          | cwl_type_array
                          | command_input_record_schema_array
                          | command_input_enum_schema_array
                          | command_input_array_schema_array
                          | string_array
                          | command_input_array_schema
                          | command_input_record_schema
                          )

command_output_record_schema ::= (record_type | command_output_record_fields | label)
command_output_record_fields ::= command_output_record_field *
command_output_record_field ::= (name | command_output_record_field_type | doc | output_binding)
command_output_record_field_type ::= (
cwl_type
| command_output_enum_schema
| STRING_TK
| cwl_type_array
| command_output_record_schema_array
| command_output_enum_schema_array
| command_output_array_schema_array
| string_array
| command_output_record_schema
| command_output_array_schema
)

command_output_enum_schema ::= (symbols | enum_type | label | output_binding)
command_output_array_schema ::= (command_output_array_items | array_type | label | output_binding)
command_output_array_items ::= command_output_record_field_type


cwl_type ::= (
NULL_TYPE_TK
| BOOLEAN_TYPE_TK
| INT_TYPE_TK
| LONG_TYPE_TK
| FLOAT_TYPE_TK
| DOUBLE_TYPE_TK
| STRING_TYPE_TK
| FILE_TYPE_TK
| DIRECTORY_TYPE_TK
)

cwl_type_array ::= LBRACKET_TK (cwl_type COMMA_TK) * cwl_type RBRACKET_TK
command_output_record_schema_array ::= LBRACKET_TK (command_output_record_schema COMMA_TK) * command_output_record_schema RBRACKET_TK
command_output_enum_schema_array ::= LBRACKET_TK (command_output_enum_schema COMMA_TK) * command_output_enum_schema RBRACKET_TK
command_output_array_schema_array ::= LBRACKET_TK (command_output_array_schema COMMA_TK) * command_output_array_schema RBRACKET_TK

command_input_record_schema_array ::= LBRACKET_TK (command_input_record_schema COMMA_TK) * command_input_record_schema RBRACKET_TK
command_input_enum_schema_array ::= LBRACKET_TK (command_input_enum_schema COMMA_TK) * command_input_enum_schema RBRACKET_TK
command_input_array_schema_array ::= LBRACKET_TK (command_input_array_schema COMMA_TK) * command_input_array_schema RBRACKET_TK
